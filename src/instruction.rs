use crate::*;

#[derive(Clone, Copy, PartialEq, Eq)]
pub enum Instruction {
  ADC,
  ADD,
  AND,
  BIT,
  CALL,
  CCF,
  CP,
  CPL,
  DAA,
  DEC,
  DI,
  EI,
  HALT,
  INC,
  JP,
  LD,
  LDH,
  NOP,
  OR,
  POP,
  PUSH,
  RES,
  RET,
  RETI,
  RL,
  RLA,
  RLC,
  RLCA,
  RR,
  RRA,
  RRC,
  RRCA,
  RST,
  SBC,
  SCF,
  SET,
  SLA,
  SRA,
  SRL,
  STOP,
  SUB,
  SWAP,
  XOR,
}
impl Instruction {
  pub fn parser<'a, I>() -> impl Parser<'a, I, Self, ErrRichTokenTree<'a>>
  where
    I: ValueInput<'a, Token = TokenTree, Span = SimpleSpan>,
  {
    select! {
      Lone(Token::InstADC) => Self::ADC,
      Lone(Token::InstADD) => Self::ADD,
      Lone(Token::InstAND) => Self::AND,
      Lone(Token::InstBIT) => Self::BIT,
      Lone(Token::InstCALL) => Self::CALL,
      Lone(Token::InstCCF) => Self::CCF,
      Lone(Token::InstCP) => Self::CP,
      Lone(Token::InstCPL) => Self::CPL,
      Lone(Token::InstDAA) => Self::DAA,
      Lone(Token::InstDEC) => Self::DEC,
      Lone(Token::InstDI) => Self::DI,
      Lone(Token::InstEI) => Self::EI,
      Lone(Token::InstHALT) => Self::HALT,
      Lone(Token::InstINC) => Self::INC,
      Lone(Token::InstJP) => Self::JP,
      Lone(Token::InstLD) => Self::LD,
      Lone(Token::InstLDH) => Self::LDH,
      Lone(Token::InstNOP) => Self::NOP,
      Lone(Token::InstOR) => Self::OR,
      Lone(Token::InstPOP) => Self::POP,
      Lone(Token::InstPUSH) => Self::PUSH,
      Lone(Token::InstRES) => Self::RES,
      Lone(Token::InstRET) => Self::RET,
      Lone(Token::InstRETI) => Self::RETI,
      Lone(Token::InstRL) => Self::RL,
      Lone(Token::InstRLA) => Self::RLA,
      Lone(Token::InstRLC) => Self::RLC,
      Lone(Token::InstRLCA) => Self::RLCA,
      Lone(Token::InstRR) => Self::RR,
      Lone(Token::InstRRA) => Self::RRA,
      Lone(Token::InstRRC) => Self::RRC,
      Lone(Token::InstRRCA) => Self::RRCA,
      Lone(Token::InstRST) => Self::RST,
      Lone(Token::InstSBC) => Self::SBC,
      Lone(Token::InstSCF) => Self::SCF,
      Lone(Token::InstSET) => Self::SET,
      Lone(Token::InstSLA) => Self::SLA,
      Lone(Token::InstSRA) => Self::SRA,
      Lone(Token::InstSRL) => Self::SRL,
      Lone(Token::InstSTOP) => Self::STOP,
      Lone(Token::InstSUB) => Self::SUB,
      Lone(Token::InstSWAP) => Self::SWAP,
      Lone(Token::InstXOR) => Self::XOR,
    }
  }
}
impl core::fmt::Debug for Instruction {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(
      f,
      "{}",
      match self {
        Self::ADC => "adc",
        Self::ADD => "add",
        Self::AND => "and",
        Self::BIT => "bit",
        Self::CALL => "call",
        Self::CCF => "ccf",
        Self::CP => "cp",
        Self::CPL => "cpl",
        Self::DAA => "daa",
        Self::DEC => "dec",
        Self::DI => "di",
        Self::EI => "ei",
        Self::HALT => "halt",
        Self::INC => "inc",
        Self::JP => "jp",
        Self::LD => "ld",
        Self::LDH => "ldh",
        Self::NOP => "nop",
        Self::OR => "or",
        Self::POP => "pop",
        Self::PUSH => "push",
        Self::RES => "res",
        Self::RET => "ret",
        Self::RETI => "reti",
        Self::RL => "rl",
        Self::RLA => "rla",
        Self::RLC => "rlc",
        Self::RLCA => "rlca",
        Self::RR => "rr",
        Self::RRA => "rra",
        Self::RRC => "rrc",
        Self::RRCA => "rrca",
        Self::RST => "rst",
        Self::SBC => "sbc",
        Self::SCF => "scf",
        Self::SET => "set",
        Self::SLA => "sla",
        Self::SRA => "sra",
        Self::SRL => "srl",
        Self::STOP => "stop",
        Self::SUB => "sub",
        Self::SWAP => "swap",
        Self::XOR => "xor",
      }
    )
  }
}
