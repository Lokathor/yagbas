use super::*;

/// A callable body of code within the program.
///
/// ```yag
/// fn name_here(args:ArgTy, arg1:ArgTy1, ...) -> ReturnTy {
///   statement;
///   statement;
///   // ..
///   return_value
/// }
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AstFunction {
  pub args: Vec<AstFunctionArg>,
  pub return_info: Option<(StrID, Span32)>,
  pub body: StatementBody,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AstFunctionArg {
  pub span: Span32,
  pub attributes: Vec<Expr>,
  pub name: StrID,
  pub name_span: Span32,
  pub ty: TypeName,
}

/// One single line of code in a body of code.
///
/// There's one `Vec<Statement>` per body of code in the AST, so we should be
/// mindful about the size of this type.
#[derive(Debug, Clone, Default, PartialEq, Eq, Hash)]
pub struct Statement {
  pub span: Span32,
  /// most statements have 0 attributes, and there are many statemnts in a
  /// program, so we Option this.
  pub attributes: Option<Box<Vec<Expr>>>,
  pub kind: Box<StatementKind>,
}


#[derive(Debug, Clone, Default, PartialEq, Eq, Hash)]
pub enum ExprKind {

  Macro(ExprMacro),
  StructLit(ExprStructLit),

  IfElse(ExprIfElse),
  Loop(ExprLoop),
  LoopTimes(ExprLoopTimes),
  Break(ExprBreak),
  Continue(ExprContinue),
  Return(ExprReturn),

  UnOp(ExprUnOp),
  BinOp(ExprBinOp),
}


#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprMacro {
  pub target: StrID,
  pub target_span: Span32,
  pub args: Vec<Expr>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStructLit {
  pub ty: StrID,
  pub ty_span: Span32,
  pub args: Vec<StructLitFieldInitKind>,
}


