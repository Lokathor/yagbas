
static mut wLastKeys = 0
static mut wCurKeys = 0
static mut wNewKeys = 0
static mut wGameState = 0
static mut wVBlankCount = 0

// todo: assign a charmapping?

fn main() {
  a = AudioMain {}
  [AudioMain] = a
  
  wait_for_one_vblank()
  init_sprite_obj_lib_wrapper()
  a = LcdCtrl {}
  [LCDC] = a
  
  load_text_font_into_vram()
  a = LcdCtrl { enabled, background, objects, object16, window, window_9C00 }
  [LCDC] = a
  
  a = palette!(0,1,2,3)
  [BGP] = a
  [OBJPAL.0] = a
}

fn wait_for_one_vblank() {
  a = 1
  [wVBlankCount] = a
  wait_for_vblank_function()
}

fn wait_for_vblank_function() {
  loop {
    a = [rLY]
    if a >= VBLANK_START {
      break
    }
  }
  a = [wVBlankCount]
  a -= 1
  [wVBlankCount] = a
  return a == 0
}

fn next_game_state() {
  wait_for_one_vblank()
  clear_background()
  a = LcdCtrl {}
  [LCDC] = a
  [rSCX] = 0
  [rSCX] = 0
  [rWX] = 0
  [rWX] = 0
  disable_interrupts()
  clear_all_sprites()
  
  // init
  a = [wGameState]
  if a == 2 {
    init_gameplay_state()
  }
  a = [wGameState]
  if a == 1 {
    init_story_state()
  }
  a = [wGameState]
  if a == 0 {
    init_title_screen_state()
  }
  
  // update
  a = [wGameState]
  if a == 2 {
    update_gameplay_state()
  } else if a == 1 {
    update_story_state()
  } else {
    update_title_screen_state()
  }
}

static PressPlayText = "press A to play"

static TitleScreenTileData = todo!()
static TitleScreenTileMap = todo!()

fn init_title_screen_state() {
  draw_title_screen()
  de = $99C3
  hl = &PressPlayText
  draw_text_tiles(hl)
  a = LcdCtrl { enabled, background, objects, object16 }
  [LCDC] = a
}

fn draw_text_tiles(hl) {
  loop {
    a = [hl]
    if a == 255 {
      return
    }
    [de] = a
    hl++
    de++
  }
}

fn draw_title_screen() {
  de = &TileScreenTitleData
  hl = $9340
  bc = size_of_static!(TileScreenTitleData)
  copy_de_into_memory_at_hl()
  
  de = &TileScreenTitleMap
  hl = $9800
  bc = size_of_static!(TileScreenTitleMap)
  copy_de_into_memory_at_hl_with_52_offset()
}

fn copy_de_into_memory_at_hl() {
  todo!()
}

fn copy_de_into_memory_at_hl_with_52_offset() {
  // here each byte has 52 added during the copy
  todo!()
}

static mut wWaitKey = 0

fn update_title_screen_state() {
  a = KeyPad { a } //PROBLEM??: cant name a field 'a' or 'b'
  [wWaitKey] = a
  wait_for_key_function()
  a = 1
  [wGameState] = a
  become!(next_game_state)
}

fn update_keys_one_nibble(a) -> a {
  [P1] = a
  known_ret()
  a = [P1]
  a = [P1]
  a = [P1]
  a |= $F0
}
fn known_return(){}
fn update_keys(a:_, b:_) -> a {
  // collect buttons
  a = P1F_GET_BTN
  a = update_keys_one_nibble(a)
  b = a // now b = *unpressed* buttons
  
  // collect directions
  a = P1F_GET_DPAD
  a = update_keys_one_nibble(a)
  
  // combine the data and fix
  swap!(a)
  a ^= b
  b = a // now b = pressed buttons + directions
  
  // release the input hardware
  a = P1F_GET_NONE
  [P1] = a
  
  // update globals
  a = [wCurKeys]
  a ^= b
  a &= b
  [wNewKeys] = a
  a = b
  [wCurKeys] = a
  return a
}

fn wait_for_key_function() {
  push!(bc) // why?
  loop {
    a = [wCurKeys]
    [wLastKeys] = a
    update_keys()
    a = [wWaitKey]
    b = a
    a = [wCurKeys] & b
    if a != 0 {
      a = [wLastKeys] & b
      if a == 0 {
        pop!(bc) // should be automatic???
        return
      }
    }
    a = 1
    [wVBlankCount] = a
    wait_for_vblank_function()
  }
}

fn init_story_state() {
  LcdCtrl { enabled, background, objects, object16, }
  [LCDF] = a
}

static Story = {
  // todo: fix this
    .Line1 db "the galatic empire", 255
    .Line2 db "rules the galaxy", 255
    .Line3 db "with an iron", 255
    .Line4 db "fist.", 255
    .Line5 db "the rebel force", 255
    .Line6 db "remain hopeful of", 255
    .Line7 db "freedoms light", 255
}

fn draw_text_with_typewriter_effect() {
  loop {
    a = 3
    [wVBlankCount] = a
    wait_for_vblank_function()
    a = [hl]
    if a == 255 {
      return
    }
    [de] = a
    hl++
    de++
  }
}

fn update_story_state() {
  // page 1
  de = $9821
  hl = Story.line1
  draw_text_with_typewriter_effect()
  de = $9861
  hl = Story.line2
  draw_text_with_typewriter_effect()
  de = $98A1
  hl = Story.line3
  draw_text_with_typewriter_effect()
  de = $98E1
  hl = Story.line4
  draw_text_with_typewriter_effect()
  a = KeyPad { a } //PROBLEM??: cant name a field 'a' or 'b'
  [wWaitKey] = a
  wait_for_key_function()
  
  // page 2
  de = $9821
  hl = Story.line5
  draw_text_with_typewriter_effect()
  de = $9861
  hl = Story.line6
  draw_text_with_typewriter_effect()
  de = $98A1
  hl = Story.line7
  draw_text_with_typewriter_effect()
  a = KeyPad { a } //PROBLEM??: cant name a field 'a' or 'b'
  [wWaitKey] = a
  wait_for_key_function()
  
  a = 2
  [wGameState] = a
  become!(next_game_state())
}

fn clear_background() {
  todo!()
  // lcd off
  // clear the memory
  // lcd on
}

static mut wScore = todo!() // array of 6
static mut wLives = 0
static ScoreText = "score"
static LivesText = "lives"

fn init_gameplay_state() {
  a = 3
  [wLives] = a
  
  // todo: zero the score
  
  initialize_background()
  initialize_player()
  initialize_bullets()
  initialize_enemies()
  
  init_stat_interrupts()
  
  de = $9C00
  hl = &ScoreText
  draw_text_tiles_loop()
  de = $9C0D
  hl = &LivesText
  draw_text_tiles_loop()
  
  draw_score()
  draw_lives()
  
  a = 0
  [rWY] = w
  a = 7
  [rWX] = a
  LcdCtrl { enabled, background, objects, object16, window, win_9C00, bg_9800 }
  [LCDF] = a
}

fn update_gameplay_state() {
  a = [wCurKeys]
  [wLastKeys] = a
  update_keys()
  reset_shadow_oam()
  reset_oam_sprite_address()
  update_player()
  update_enemies()
  update_bullets()
  update_background()
  clear_remaining_sprites()
  a = [wLives]
  if a == 0 {
    [wGameState] = 0
    become!(next_game_state)
  } else {
    wait_for_one_vblank()
    a = high!(wShadowOAM)
    hOAMDMA()
    wait_for_one_vblank()
    become!(update_gameplay_state)
  }
}

fn reset_oam_sprite_address() {
  a = 0
  [wSpritesUsed] = a
  a = low!(wShadowOAM)
  [wLastOAMAddress] = a
  a = high!(wShadowOAM)
  [wLastOAMAddress+1] = a
}

// todo: Scrolling Background
