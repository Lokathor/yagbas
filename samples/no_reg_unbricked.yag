
const BRICK_LEFT = 5
const BRICK_RIGHT = 6
const BLANK_TILE = 0
const DIGIT_TILE_OFFSET = $1A
const SCORE_TENS = $9870
const SCORE_ONES = $9871
const VBLANK_START = 144
const PADDLE = 0
const BALL = 1

static mut wCurKeys = 0
static mut wNewKeys = 0
static mut wBallMomentumX = 1
static mut wBallMomentumY = -1
static mut wScore = 0

fn main(_) {
  [AudioMain] = AudioMain {}
  
  safe_disable_lcd()
  
  memcpy($8000, Paddle, size_of_static!(Paddle))
  memcpy($8010, Ball, size_of_static!(Ball))
  memcpy($9000, Tiles, size_of_static!(Tiles))
  memcpy($9800, TileMap, size_of_static!(TileMap))
  
  memclr(OAMRAM, size_of_static!(OAMRAM))
  
  write_obj!(PADDLE, OamEntry {
    y=128+16,
    x=16+8,
    tile_id=PADDLE,
    attrs=0,
  })
  
  write_obj!(BALL, OamEntry {
    y=100+16,
    x=32+8,
    tile_id=BALL,
    attrs=0,
  })
  
  [IF] = Interrupts {}
  [IE] = Interrupts { vblank }
  enable_interrupts!()
  
  let pal = palette!(0,1,2,3)
  [BGP] = pal
  [OBJ_PAL.0] = pal
  [LCDC] = LcdCtrl { enabled, background, objects }
  
  'gameplay: loop {
    halt!() // halts until an irq returns.
    update_keys()
    update_objects()
    do_movement()
    do_bounces()
  }
}

#[interrupt_handler(vblank)]
fn vblank_handler() {}

fn safe_disable_lcd() {
  loop {
    // note: volatile read.
    if [LY] == VBLANK_START {
      [LCDC] = LcdCtrl {}
      return
    }
  }
}

fn update_objects() {
  if [wCurKeys].left {
    [OAMRAM.PADDLE.x] -= 1
  } else if [wCurKeys].right {
    [OAMRAM.PADDLE.x] += 1
  };
  
  [OAMRAM.BALL.x] += [wBallMomentumX]
  [OAMRAM.BALL.y] += [wBallMomentumY]
}

fn do_bounces() {
  // bounce on top
  let tile = get_tile_by_pixel(
    [OAMRAM.BALL.x] - 8,
    [OAMRAM.BALL.y] - (16+1),
  )
  if is_wall_tile([tile]) {
    check_and_handle_brick(tile)
    [wBallMomentumY] = 1
  }
  
  // bounce on right
  let tile = get_tile_by_pixel(
    [OAMRAM.BALL.x] - (8-1),
    [OAMRAM.BALL.y] - 16,
  )
  if is_wall_tile([tile]) {
    check_and_handle_brick(tile)
    [wBallMomentumX] = -1
  }
  
  // bounce on left
  let tile = get_tile_by_pixel(
    [OAMRAM.BALL.x] - (8+1),
    [OAMRAM.BALL.y] - 16,
  )
  if is_wall_tile([tile]) {
    check_and_handle_brick(tile)
    [wBallMomentumX] = 1
  }
  
  // bounce on bottom
  let tile = get_tile_by_pixel(
    [OAMRAM.BALL.x] - 8,
    [OAMRAM.BALL.y] - (16-1),
  )
  if is_wall_tile([tile]) {
    check_and_handle_brick(tile)
    [wBallMomentumY] = -1
  }
  
  // bounce off paddle
  todo!()
}

fn increase_score() {
  [wScore] += 1
  decimal_adjust!([wScore])
  if [wScore] > $99 {
    [wScore] = $99
  }
  [SCORE_TENS] = high_nibble!([wScore]) + DIGIT_TILE_OFFSET
  [SCORE_ONES] = low_nibble!([wScore]) + DIGIT_TILE_OFFSET
}

fn check_and_handle_brick(tile_addr) {
  if [tile_addr] == BRICK_LEFT {
    [tile_addr] = BLANK_TILE
    [tile_addr+1] = BLANK_TILE
    increase_score()
  } else if [tile_addr] == BRICK_RIGHT {
    [tile_addr] = BLANK_TILE
    [tile_addr+1] = BLANK_TILE
    increase_score()
  }
}

fn get_tile_by_pixel(x_pix: U8, y_pix: U8) -> Usize {
  let y_tile = y_pix / 8
  let x_tile = x_pix / 8
  return $9800 + (y_tile*32) + x_tile
}

// a = tile id
// zf = if a is a wall tile.
fn is_wall_tile(a) -> bool {
  if a == 0 {
    return true
  }
  if a == 1 {
    return true
  }
  if a == 2 {
    return true
  }
  // skip 3
  if a == 4 {
    return true
  }
  if a == 5 {
    return true
  }
  if a == 6 {
    return true
  }
  if a == 7 {
    return true
  }
  return false
}

fn update_keys_one_nibble(a) -> a {
  [P1] = a
  known_ret()
  a = [P1]
  a = [P1]
  a = [P1]
  a |= $F0
}
fn known_return(){}
fn update_keys(a:_, b:_) -> a {
  // collect buttons
  a = P1F_GET_BTN
  a = update_keys_one_nibble(a)
  b = a // now b = *unpressed* buttons
  
  // collect directions
  a = P1F_GET_DPAD
  a = update_keys_one_nibble(a)
  
  // combine the data and fix
  swap!(a)
  a ^= b
  b = a // now b = pressed buttons + directions
  
  // release the input hardware
  a = P1F_GET_NONE
  [P1] = a
  
  // update globals
  a = [wCurKeys]
  a ^= b
  a &= b
  [wNewKeys] = a
  a = b
  [wCurKeys] = a
  return a
}

// Copies `bc` bytes from `de` to `hl`.
// * Assumes that `bc` is non-zero
fn memcpy(_) {
  bc--
  b++
  c++
  loop {
    a = [de]
    [hl++] = a
    de++
    if c-- != 0 {
      continue
    }
    if b-- != 0 {
      continue
    }
	  return
  }
}
