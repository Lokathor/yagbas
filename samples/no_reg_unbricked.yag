
const BRICK_LEFT = 5
const BRICK_RIGHT = 6
const BLANK_TILE = 0
const DIGIT_TILE_OFFSET = $1A
const SCORE_TENS = $9870
const SCORE_ONES = $9871
const VBLANK_START = 144
const PADDLE = 0
const BALL = 1

static mut wCurKeys = 0
static mut wNewKeys = 0
static mut wBallMomentumX = 1
static mut wBallMomentumY = -1
static mut wScore = 0

fn safe_disable_lcd() {
  loop {
    if [LY] == VBLANK_START {
      [LCDC] = LcdCtrl {}
      return
    }
  }
}

fn main(_) {
  [AudioMain] = AudioMain {}
  
  safe_disable_lcd()
  
  memcpy($8000, Paddle, size_of_static!(Paddle))
  memcpy($8010, Ball, size_of_static!(Ball))
  memcpy($9000, Tiles, size_of_static!(Tiles))
  memcpy($9800, TileMap, size_of_static!(TileMap))
  
  memclr(OAMRAM, size_of_static!(OAMRAM))
  
  write_obj!(PADDLE, OamEntry {
    y=128+16,
    x=16+8,
    tile_id=PADDLE,
    attrs=0,
  })
  
  write_obj!(BALL, OamEntry {
    y=100+16,
    x=32+8,
    tile_id=BALL,
    attrs=0,
  })
  
  let pal = palette!(0,1,2,3)
  [BGP] = pal
  [OBJ_PAL.0] = pal
  [LCDC] = LcdCtrl { enabled, background, objects }
  
  'gameplay: loop {
    'wait_for_vblank: loop {
      if [LY] == VBLANK_START {
        break 'wait_for_vblank
      }
    }
    
    update_keys()
    do_movement()
    do_bounces()
  }
}

fn update_objects() {
  if [wCurKeys].left {
    [OAMRAM.PADDLE.x] -= 1
  } else if [wCurKeys].right {
    [OAMRAM.PADDLE.x] += 1
  };
  
  [OAMRAM.BALL.x] += [wBallMomentumX]
  [OAMRAM.BALL.y] += [wBallMomentumY]
}

fn do_bounces() {
  // bounce on top
  let tile = get_tile_by_pixel(
    [OAMRAM.BALL.x] - 8,
    [OAMRAM.BALL.y] - (16+1),
  )
  if is_wall_tile([tile]) {
    check_and_handle_brick(tile)
    [wBallMomentumY] = 1
  }
  
  // bounce on right
  let tile = get_tile_by_pixel(
    [OAMRAM.BALL.x] - (8-1),
    [OAMRAM.BALL.y] - 16,
  )
  if is_wall_tile([tile]) {
    check_and_handle_brick(tile)
    [wBallMomentumX] = -1
  }
  
  // bounce on left
  let tile = get_tile_by_pixel(
    [OAMRAM.BALL.x] - (8+1),
    [OAMRAM.BALL.y] - 16,
  )
  if is_wall_tile([tile]) {
    check_and_handle_brick(tile)
    [wBallMomentumX] = 1
  }
  
  // bounce on bottom
  let tile = get_tile_by_pixel(
    [OAMRAM.BALL.x] - 8,
    [OAMRAM.BALL.y] - (16-1),
  )
  if is_wall_tile([tile]) {
    check_and_handle_brick(tile)
    [wBallMomentumY] = -1
  }
  
  // bounce off paddle
  todo!()
}

fn increase_score_packed_bcd(a:_,hl:_){
  hl = &wScore
  a = 1
  a += [hl]
  decimal_adjust_a!()
  if a > $99 {
    a = $99
  }
  [hl] = a
  update_score_board()
}

fn update_score_board(a:_) {
  a = high_nibble!([wScore]) + DIGIT_TILE_OFFSET
  [SCORE_TENS] = a
  a = low_nibble!([wScore]) + DIGIT_TILE_OFFSET
  [SCORE_ONES] = a
}

fn check_and_handle_brick(a:_, hl) {
  a = [hl]
  if a == BRICK_LEFT {
    [hl] = BLANK_TILE
    hl++
    [hl] = BLANK_TILE
    increase_score_packed_bcd(a,hl)
  } else if a == BRICK_RIGHT {
    [hl] = BLANK_TILE
    hl--
    [hl] = BLANK_TILE
    increase_score_packed_bcd(a,hl)
  }
}

// b = X
// c = Y
// return = the tile address
fn get_tile_by_pixel(a:_,b,c) -> hl {
  a = c & %1111_1000
  hl = a
  hl *= 4
  a = (b / 8) + 1
  l = a
  a += h + carry
  a -= l
  h = a
  bc = $9800
  hl += bc
  return hl
}

// a = tile id
// zf = if a is a wall tile.
fn is_wall_tile(a) -> zf {
  if a == 0 {
    return true
  }
  if a == 1 {
    return true
  }
  if a == 2 {
    return true
  }
  // skip 3
  if a == 4 {
    return true
  }
  if a == 5 {
    return true
  }
  if a == 6 {
    return true
  }
  if a == 7 {
    return true
  }
  return false
}

fn update_keys_one_nibble(a) -> a {
  [P1] = a
  known_ret()
  a = [P1]
  a = [P1]
  a = [P1]
  a |= $F0
}
fn known_return(){}
fn update_keys(a:_, b:_) -> a {
  // collect buttons
  a = P1F_GET_BTN
  a = update_keys_one_nibble(a)
  b = a // now b = *unpressed* buttons
  
  // collect directions
  a = P1F_GET_DPAD
  a = update_keys_one_nibble(a)
  
  // combine the data and fix
  swap!(a)
  a ^= b
  b = a // now b = pressed buttons + directions
  
  // release the input hardware
  a = P1F_GET_NONE
  [P1] = a
  
  // update globals
  a = [wCurKeys]
  a ^= b
  a &= b
  [wNewKeys] = a
  a = b
  [wCurKeys] = a
  return a
}

// Copies `bc` bytes from `de` to `hl`.
// * Assumes that `bc` is non-zero
fn memcpy(_) {
  bc--
  b++
  c++
  loop {
    a = [de]
    [hl++] = a
    de++
    if c-- != 0 {
      continue
    }
    if b-- != 0 {
      continue
    }
	  return
  }
}
