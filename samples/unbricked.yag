
const BRICK_LEFT = 5
const BRICK_RIGHT = 6
const BLANK_TILE = 0
const DIGIT_TILE_OFFSET = $1A
const SCORE_TENS = $9870
const SCORE_ONES = $9871
const VBLANK_START = 144
const PADDLE = 0
const BALL = 1

static mut wCurKeys = 0
static mut wNewKeys = 0
static mut wBallMomentumX = 1
static mut wBallMomentumY = -1
static mut wScore = 0

fn main(_) {
  a = AudioMain {}
  [AudioMain] = a
  
  'wait_for_vblank: loop {
    a = [LY]
    if a == VBLANK_START {
      a = LcdCtrl {}
      [LCDC] = a
      break 'wait_for_vblank
    }
  }
  
  de = &Tiles
  hl = $9000
  bc = size_of_static!(Tiles)
  memcpy(_)
  
  de = &TileMap
  hl = $9800
  bc = size_of_static!(TileMap)
  memcpy(_)
  
  de = &Paddle
  hl = $8000
  bc = size_of_static!(Paddle)
  memcpy(_)
  
  de = &Ball
  hl = $8010
  bc = size_of_static!(Ball)
  memcpy(_)
  
  a = 0
  b = 160
  hl = &OAMRAM
  'clear_oam: loop {
    [hl++] = a
    if b-- == 0 {
      break 'clear_oam
    }
  }
  
  write_obj!(PADDLE, OamEntry {
    y=128+16,
    x=16+8,
    tile_id=PADDLE,
    attrs=0,
  })
  
  write_obj!(BALL, OamEntry {
    y=100+16,
    x=32+8,
    tile_id=BALL,
    attrs=0,
  })
  
  a = palette!(0,1,2,3)
  [BGP] = a
  [OBJ_PAL.0] = a
  a = LcdCtrl { enabled, background, objects }
  [LCDC] = a
  
  'gameplay: loop {
    'wait_for_vblank: loop {
      a = [LY]
      if a == VBLANK_START {
        break 'wait_for_vblank
      }
    }
    
    update_keys(a=_,b=_)
    
    do_movement(_)
    
    do_bounces(_)
  }
}

fn update_objects(_) {
  a = [wCurKeys]
  
  if a.PadF.left {
      a = [OAMRAM.PADDLE.x]
      a--
      [OAMRAM.PADDLE.x] = a
    } else if a.PadF.right {
      a = [OAMRAM.PADDLE.x]
      a++
      [OAMRAM.PADDLE.x] = a
    }
    
    a = [wBallMomentumX]
    b = a
    a = [OAMRAM.BALL.x]
    a += b
    [OAMRAM.BALL.x] = a
    
    a = [wBallMomentumY]
    b = a
    a = [OAMRAM.BALL.y]
    a += b
    [OAMRAM.BALL.y] = a
}

fn do_bounces(_) {
  // bounce on top
    a = [OAMRAM.BALL.x] - 8
    b = a
    a = [OAMRAM.BALL.y] - (16+1)
    c = a
    hl = get_tile_by_pixel(a,b,c)
    a = [hl]
    if is_wall_tile(a) {
      check_and_handle_brick(a, hl)
      a = 1
      [wBallMomentumY] = a
    }
    
    // bounce on right
    a = [OAMRAM.BALL.x] - (8-1)
    b = a
    a = [OAMRAM.BALL.y] - 16
    c = a
    hl = get_tile_by_pixel(a,b,c)
    a = [hl]
    if is_wall_tile(a) {
      check_and_handle_brick(a, hl)
      a = -1
      [wBallMomentumX] = a
    }
    
    // bounce on left
    a = [OAMRAM.BALL.x] - (8+1)
    b = a
    a = [OAMRAM.BALL.y] - 16
    c = a
    hl = get_tile_by_pixel(a,b,c)
    a = [hl]
    if is_wall_tile(a) {
      check_and_handle_brick(a, hl)
      a = 1
      [wBallMomentumX] = a
    }
    
    // bounce on bottom
    a = [OAMRAM.BALL.x] - 8
    b = a
    a = [OAMRAM.BALL.y] - (16-1)
    c = a
    hl = get_tile_by_pixel(a,b,c)
    a = [hl]
    if is_wall_tile(a) {
      check_and_handle_brick(a, hl)
      a = -1
      [wBallMomentumY] = a
    }
    
    // bounce off paddle
    a = [OAMRAM.PADDLE.y]
    b = a
    a = [OAMRAM.BALL.y] + 6
    if a == b {
      a = [OAMRAM.BALL.x]
      b = a
      a = [OAMRAM.PADDLE.x] - 8
      if a == b {
        a += (8+16)
        if a < b {
          a = -1
          [wBallMomentum] = a
        }
      }
    }
}

fn increase_score_packed_bcd(a:_,hl:_){
  hl = &wScore
  a = 1
  a += [hl]
  decimal_adjust_a!()
  if a > $99 {
    a = $99
  }
  [hl] = a
  update_score_board()
}

fn update_score_board(a:_) {
  a = high_nibble!([wScore]) + DIGIT_TILE_OFFSET
  [SCORE_TENS] = a
  a = low_nibble!([wScore]) + DIGIT_TILE_OFFSET
  [SCORE_ONES] = a
}

fn check_and_handle_brick(a:_, hl) {
  a = [hl]
  if a == BRICK_LEFT {
    [hl] = BLANK_TILE
    hl++
    [hl] = BLANK_TILE
    increase_score_packed_bcd(a,hl)
  } else if a == BRICK_RIGHT {
    [hl] = BLANK_TILE
    hl--
    [hl] = BLANK_TILE
    increase_score_packed_bcd(a,hl)
  }
}

// b = X
// c = Y
// return = the tile address
fn get_tile_by_pixel(a:_,b,c) -> hl {
  a = c & %1111_1000
  hl = a
  hl *= 4
  a = (b / 8) + 1
  l = a
  a += h + carry
  a -= l
  h = a
  bc = $9800
  hl += bc
  return hl
}

// a = tile id
// zf = if a is a wall tile.
fn is_wall_tile(a) -> zf {
  if a == 0 {
    return true
  }
  if a == 1 {
    return true
  }
  if a == 2 {
    return true
  }
  // skip 3
  if a == 4 {
    return true
  }
  if a == 5 {
    return true
  }
  if a == 6 {
    return true
  }
  if a == 7 {
    return true
  }
  return false
}

fn update_keys_one_nibble(a) -> a {
  [P1] = a
  known_ret()
  a = [P1]
  a = [P1]
  a = [P1]
  a |= $F0
}
fn known_return(){}
fn update_keys(a:_, b:_) -> a {
  // collect buttons
  a = P1F_GET_BTN
  a = update_keys_one_nibble(a)
  b = a // now b = *unpressed* buttons
  
  // collect directions
  a = P1F_GET_DPAD
  a = update_keys_one_nibble(a)
  
  // combine the data and fix
  swap!(a)
  a ^= b
  b = a // now b = pressed buttons + directions
  
  // release the input hardware
  a = P1F_GET_NONE
  [P1] = a
  
  // update globals
  a = [wCurKeys]
  a ^= b
  a &= b
  [wNewKeys] = a
  a = b
  [wCurKeys] = a
  return a
}

// Copies `bc` bytes from `de` to `hl`.
// * Assumes that `bc` is non-zero
fn memcpy(_) {
  bc--
  b++
  c++
  loop {
    a = [de]
    [hl++] = a
    de++
    if c-- != 0 {
      continue
    }
    if b-- != 0 {
      continue
    }
	  return
  }
}
